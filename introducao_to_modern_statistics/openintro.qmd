---
title: "openintro"
format: html
editor: visual
autor: V. Paixao
---

## Lição 1: Linguagem dos Dados:

## **Objetivos:**

-   Carregar dados do pacote complementar do livro didático;

-   Introduzir quadros de dados e dados organizados;

-   Discuta os tipos de variáveis ​​que conectam a terminologia do livro didático ao R e

-   Mude quadros de dados para converter tipos de dados.

    -   Conversão numérica para categórica

    -   Filtragem e depois queda de níveis

    -   Combine níveis de categóricos

    -   Crie uma nova variável com base em duas variáveis ​​existentes (por exemplo, IMC)

### Pacotes utilizados:

```{r}
library(tidyverse) # coleção de pacotes para data science.
library(openintro) # carregando conjunto de dados open intro.

```

### Bases de Dados (openintro):

-   Inspecionar a base de dados usando glimpse(), str(), hard():

-   Verificar:

    -   nº de variáveis e observações;

    -   nome das variáveis e seus significados;

    -   tipo de dado de cada variável;

```{r}
# bases de dados do pct openintro.
## primerio data frame: 
high_school_beyond <- hsb2 # atribuindo o df ao objeto. high_school_beyond  
glimpse(high_school_beyond) # inspeciona df: nº linha x col, var e tipo dados.
str(high_school_beyond) # inspeciona df: nº linha x col, var, tipo dado e levels.

## segundo data frame:
email_50 <- email50
glimpse(email_50)
head(high_school_beyond,10) # inspeciona df: var, tipos de dado, 10 primeiras linhas.
```

### Tipos de Variáveis:

-   Quantitativas (contínuas ou discretas) e

-   Qualitativas (ordinais, nominais, categóricas).

-   Obs.: Estatística de resumo, visualização e o método estatístico variam conforme o tipo de variável.

```{r}
# Tipos de variáveis: df high_school_beyond
## Var. Quant. Discretas: read, write, math, science, socst.
glimpse(high_school_beyond$read)
summary(high_school_beyond$read)

glimpse(high_school_beyond$write)
summary(high_school_beyond$write)

glimpse(high_school_beyond$math)
summary(high_school_beyond$math)

glimpse(high_school_beyond$science)
summary(high_school_beyond$science)

glimpse(high_school_beyond$socst)
summary(high_school_beyond$socst)

## Var. Quant. Continuas: null

## Var. Quali. Ordinal: id
glimpse(high_school_beyond$id)
high_school_beyond %>% 
  select(id) %>%
  arrange(id) # ordena o df conf. os valores de uma coluna.

## Var. Quali. Nominais: null

#Var. Quali. Categóricas Nominal: gender, race, ses, schtyp, prog.  
glimpse(high_school_beyond$gender)
unique(high_school_beyond$gender) 

glimpse(high_school_beyond$race)
unique(high_school_beyond$race)

glimpse(high_school_beyond$ses)
unique(high_school_beyond$ses)

glimpse(high_school_beyond$schtyp)

glimpse(high_school_beyond$prog)
levels(high_school_beyond$prog)

```

```{r}

# Tipos de variáveis: df email50
glimpse(email_50)

## var. Quant. Discretas: cc, image, attach, dollar, password, line_breaks, exclaim_mess.
glimpse(email_50$cc) #Number of people cc'ed.
summary(email_50$cc)
unique(email_50$cc)

glimpse(email_50$image) #The number of images attached.
summary(email_50$image)
unique(email_50$image)

glimpse(email_50$attach)
summary(email_50$attach)
unique(email_50$attach)

glimpse(email_50$dollar) #The number of times a dollar sign or the word “dollar” appeared in the email.
summary(email_50$dollar)
email_50$dollar

glimpse(email_50$password) #The number of times “password” appeared in the email.
summary(email_50$password)

glimpse(email_50$line_breaks) #The number of line breaks in the email (does not count text wrapping).
summary(email_50$line_breaks)

glimpse(email_50$exclaim_mess)
summary(email_50$exclaim_mess)

## var. Quant. Continuas: num_char (in thousands)
glimpse(email_50$num_char)
summary(email_50$num_char)
email_50$num_char # The number of characters in the email, in thousands.

##Var. Quali. Ordinais: time, number.
glimpse(email_50$time)

##Var. Quali. categorica Ordinal: number.
glimpse(email_50$number) # Factor variable saying whether there was no number, a small number (under 1 million), or a big number.
unique(email_50$number)

##Var. Quali. Nominais: null

##Var. Quali. Categorica Nominal: spam, to_multiple, from, sent_email, winner, inherit, viagra, format, re_subj, exclaim_subj e urgent_subj.

glimpse(email_50$spam) #Indicator for whether the email was spam. "0" = não tem spam, "1" = Sim, tem spam. 

glimpse(email_50$to_multiple) #Indicator for whether the email was addressed to more than one recipient.

glimpse(email_50$from) #Whether the message was listed as from anyone.

glimpse(email_50$sent_email) #Indicator for whether the sender had been sent an email in the last 30 days.

glimpse(email_50$winner) #Indicates whether “winner” appeared in the email.

glimpse(email_50$inherit) #The number of times “inherit” (or an extension, such as “inheritance”) appeared in the email.
unique(email_50 $inherit)

glimpse(email_50$viagra) #The number of times “viagra” appeared in the email.
unique(email_50$viagra)

glimpse(email_50$format) # Indicates whether the email was written using HTML (e.g. may have included bolding or active links). 

glimpse(email_50$re_subj) # Whether the subject started with “Re:”, “RE:”, “re:”, or “rE:”.

glimpse(email_50$exclaim_subj) # Whether there was an exclamation point in the subject.
unique(email_50$exclaim_subj)

glimpse(email_50$urgent_subj) # Whether the word “urgent” was in the email subject.
```

### Dados categóricos em R: *factors.*

```{r}
# Contar.
high_school_beyond %>%
  count(schtyp) 
##ou 
count(high_school_beyond, schtyp)

# Somar:
sum(3,4)
##ou
3 %>%
  sum(4)

# Filtrar
h_S_public <- high_school_beyond %>%
  filter(schtyp == "public") # é igual (==); factor são caracteres.
h_S_public %>% 
  count(schtyp)

glimpse(email_50$number)
unique(email_50$number)
email50_big <- email_50 %>%
  filter(number == "big")
glimpse(email50_big)
```

### Discretizar Variáveis:

Converter uma variável numérica em uma variável categórica.

```{r}
# df high_school_beyond
(avg_read <- mean(high_school_beyond$read)) # colocar entre () imprime o resultado atribuído à variável.

high_school_beyond %>% 
  mutate(read_cat = if_else(read < avg_read, 
        "reprovado", 
        "aprovado"))

```

```{r}
med_num_Char <- median(email_50$num_char)
email_50 %>%
  mutate(num_char_cat = if_else((num_char < med_num_Char),
                                "abaixo mediana",
                                "satisfatorio")) %>%
  count(num_char_cat)

```

### Combinando Níveis de um fator diferente.

```{r}
glimpse(email_50)
email_50 %>% 
  mutate (number_cate = if_else(number == "none", "no", "yes")) %>% 
  select(number, number_cate)

```

### Visualização de Dados Numéricos

```{r}
glimpse(high_school_beyond)
summary(high_school_beyond)
# Em summary:
## chr: nº de linhas;
## int: summary e
## fct: levels.

#library(ggplot2) # faz parte do tidyverse
# Gráfico Bivariado (science, math)
ggplot(data = high_school_beyond, 
       aes(x = science, y = math)) +
  geom_point()

#Interpretando a visualização: Existe uma relação positiva entre as notas de math e science.
```

```{r}
# Gráfico Multivariado (science, math, prog)
ggplot(data = high_school_beyond, 
       aes(x = science, y = math, color = prog)) +
  geom_point() + 
  ggtitle("Math and Science Grades by Program")
```

```{r}
glimpse(email_50)
ggplot(data = email_50, 
       aes(x = exclaim_mess, y = num_char, color = spam)) +
  geom_point() + 
  ggtitle("Email with exclaim_mess and num_char by spam.")
  
```

# Lição 2: Tipos de Estudo:

## **Objetivos:**

-   Definir estudos experimentais e observacionais;

-   Discuta o escopo da grade de inferência 2x2 com atribuição aleatorias e amostragem aleatórias;

-   Defina o paradoxo de Simpson em um caso de 2 cat var.

    -   Use R para fazer uma tabela de contingência

    -   `group_by()`terceira variável e faça a tabela novamente para demonstrar o paradoxo de Simpson

### Estudo Observacional e Experimental:

-   Estudo Observacional: Estabelece uma associação entre variável resposta e explicativa. Não interfere em como os dados surgem.

-   Experimento: Estabelece uma conexão de causa e efeito entre a variável resposta e a explicativa.

    -   Grupo de Tratamento e Grupo de Controle.

    -   São atribuídas aos grupos de forma aleatória.

### Pacotes utilizados:

```{r}
library(gapminder)
```

### Bases de Dados do Openintro(gapminder):

Trecho dos dados do Gapminder sobre expectativa de vida, PIB per capita e população por país.

```{r}
# Base de Dados do pct openintro.
head(gapminder)
str(gapminder)
```

### Amostragem Aleatória e Atribuição Aleatória:

-   Amostragem Aleatória: Sujeitos selecionados aleatoriamente da população de interesse.

    -   Amostra representativa da população

    -   Generalização sobre a população

-   Atribuição Aleatória:

    -   Sujeitos atribuídos de forma aleatória aos grupos tratamento e controle

        -   Cenário experimental

        -   Conclusões causais

### Paradoxo de Simpson:

-   Paradoxo de Simposon: Não considerar uma variável importante como tal para o relacionamento entre variáveis.

    -   Uma outra variável explicativa pode mudar a aparente relação entre outras var. expli. e a variável resposta.

-   Variável Resposta: Afetada

-   Variável Explicativa: Afeta

```{r}
glimpse(ucb_admit)
unique(ucb_admit$dep)
unique(ucb_admit$gender)
unique(ucb_admit$admit)

# Dados de Admissao Berkeley
ucb_admit %>%
  count(gender, admit)
## Ou (São diferentes para outras situacoes)
ucb_admit %>%
  group_by(gender) %>%
  count(admit) 

# Homens e Mulheres Admitidos.
ucb_admit %>%
  group_by(gender) %>%
  count(admit) %>%
  filter(admit == "admitted")

# Proporcao admitidos rejeitados por genero. (versao do Livro)
ucb_admit %>%
  group_by(gender) %>%
  count(admit) %>%
  mutate(prop_h_m = n/sum(n))

## Proporcao admitidos e rejeitados em Relacao ao Total. (Minha Versao)
ucb_admit %>%
  count(admit, gender) %>% # Usar group_by dificultaria a proporcao total.
  mutate(prop_h_m_admitidos = n/sum(n))
  
# Proporcao Genero Admitidos em Relacao ao Total.
ucb_admit %>%
  count(gender, admit) %>%
  mutate(prop_h_m_admit = n/sum(n)) %>%
  filter(admit == "admitted")

## Proporcao Homens Admitidos em Relacao ao Total de Admitidos.
ucb_admit %>% 
  count(gender, admit) %>%
  mutate(prop = n/sum(n)) %>%
  filter(admit == "admitted", gender == "male")

# Proporcao Homens Admitidos em cada Departamento em relacao ao total.(Minha Versão)
ucb_admit %>%
  count(dept, gender, admit) %>%
  mutate(prop_h_admit_dep = n/sum(n)) %>%
  filter(gender == "male", admit == "admitted")

# Proporcao Homens Admitidos em cada Departamento.(Versão do Livro)
ucb_admit %>%
  group_by(dept, gender) %>%
  count(admit) %>%
  mutate(prop_h_admit_dep = n/sum(n)) %>%
  filter(gender == "male", admit == "admitted")

## Proporcao Homens Admitidos por Departamento em Relacao ao Total de Admitidos.(Minha Versao)
ucb_admit %>%
  count(dept, gender, admit) %>%
  mutate(prop_h_admit_dep = n/sum(n)) %>%
  filter(gender == "male", admit == "admitted")

# 




# __________________________________________________________________________
%>%
  group_by()
    mutate(prop = n/sum(n)) %>%
  filter(admit == "admitted")





##################1º Proporcao por generos:
ucb_admit %>%
  count(gender) %>%
  mutate(prop = n /sum(n))

#2º Proporcao de admissao/rejeicao em cada genero.
ucb_admit %>%
  group_by(gender) %>% 
  count(admit) %>%
  mutate(prop = n /sum(n))

# Proporcao de Admitidos em cada Genero.
## Essa é a proposta do livro, mas discordo. O ideal seria o tópico seguinte
ucb_admit %>%
  group_by(gender) %>%
  count(admit) %>% #conta por admissao. Importante para a proporção.
  mutate(prop = n / sum(n)) %>%
  filter(admit == "admitted")

# Proporcao de Admitidos e Rejeitados por Genero. 
ucb_admit %>%
group_by(admit)%>%
  count(gender) %>%
  mutate(prop = n / sum(n)) %>%
  filter()

# 
ucb_admit %>% 
  count(dept, gender, admit) %>%
  group_by(dept, admit) %>%
    mutate(prop = n/sum(n)) 

%>% 
  filter(gender =="male", admit == "admitted") 

# Homens admitidos por departamento.
unique(ucb_admit$admit)
ucb_admit %>%
  group_by(dept, gender) %>%
  count(admit) %>% 
  mutate(prop = n/sum(n)) 

%>%
    filter(gender == "male", admit == "admitted")  

# Taxa de admissão por departamento
ucb_admit %>%
  group_by(dept, gender)%>%
  count(admit) %>%
  mutate(prop = n / sum(n)) %>% 
  filter(admit == "admitted") 

```
